IDEAL
MODEL small
STACK 100h

DATASEG

; *********************************IMAGES *****************************************
palette dw 3
db 0,0,0,63,63,63,63,63,63

playerRect db RectId
dw 5, 30
db 1

ballRect db RectId
dw 3, 3
db 1

letter0 db ImageId
dw 7, 15
db -1,5 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1
db 4 dup(2),-1,-1,-1,9 dup(2),-1,5 dup(2),-1

letter1 db ImageId
dw 7, 15
db -1,-1,-1,2,2,5 dup(-1),2,2,4 dup(-1),2,2,2,4 dup(-1),2,2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2
db 5 dup(-1),2,2,-1,-1

letter2 db ImageId
dw 7, 15
db -1,5 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,2,2,4 dup(-1),2,2,2,4 dup(-1),2,2,4 dup(-1),2,2,2,4 dup(-1),2,2,4 dup(-1),2,2,2,4 dup(-1),2,2,4 dup(-1),2,2,2,4 dup(-1),2,2
db 4 dup(-1),14 dup(2)

letter3 db ImageId
dw 7, 15
db -1,5 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,2,2,5 dup(-1),2,2,-1,-1,-1,2,2,2,-1,-1,-1,2,2,2,5 dup(-1),2,2,2,6 dup(-1),4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1
db 9 dup(2),-1,5 dup(2),-1

letter4 db ImageId
dw 8, 15
db 4 dup(-1),2,2,5 dup(-1),2,2,6 dup(-1),2,2,6 dup(-1),2,2,5 dup(-1),2,2,6 dup(-1),2,2,5 dup(-1),2,2,-1,-1,2,2,-1,-1,2,2,-1,-1,2,2,-1,-1,2,2,-1,-1,2,2,-1,2,2,-1,-1,-1,2,2,-1,16 dup(2),5 dup(-1),2,2
db 6 dup(-1),2,2,6 dup(-1),2,2,-1

letter5 db ImageId
dw 7, 15
db 16 dup(2),5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),6 dup(2),-1,7 dup(2),5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,9 dup(2),-1,5 dup(2),-1

letter6 db ImageId
dw 7, 15
db -1,5 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),5 dup(-1),2,2,5 dup(-1),6 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,9 dup(2),-1
db 5 dup(2),-1

letter7 db ImageId
dw 7, 15
db 16 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,2,2,4 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,4 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,5 dup(-1),2,2,4 dup(-1),2,2,5 dup(-1),2,2
db -1,-1,-1

letter8 db ImageId
dw 7, 15
db -1,5 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,2,2,-1,2,2,-1,2,2,-1,-1,5 dup(2),-1,-1,2,2,-1,2,2,-1,2,2,-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2)
db -1,-1,-1,9 dup(2),-1,5 dup(2),-1

letter9 db ImageId
dw 7, 15
db -1,5 dup(2),-1,9 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,9 dup(2),-1,6 dup(2),5 dup(-1),2,2,5 dup(-1),4 dup(2),-1,-1,-1,4 dup(2),-1,-1,-1,9 dup(2),-1
db 5 dup(2),-1

letterNeg db ImageId
dw 8, 15
db 56 dup(-1),16 dup(2),48 dup(-1)

letterArray db ArrayId
dw 10, 2, offset letter0, offset letter1, offset letter2, offset letter3, offset letter4, offset letter5, offset letter6, offset letter7, offset letter8, offset letter9

leftPlayerController db 3
db PhysicsComponentId
db 7
db RenderComponentId
db 23
dw 1 dup(0)
dw 0, 0, 0, 100  ; vx, ax, fx, mx
dw 0, 0, 20, 100  ; vy, ay, fy, my
dw 0, offset playerRect, 0, 0, 5, 30 ; pos, image, prev-pos, rotation, width, height
db 5*30 dup(0) ; background save place

rightPlayerController db 3
db PhysicsComponentId
db 7
db RenderComponentId
db 23
dw 1 dup(0)
dw 0, 0, 0, 100  ; vx, ax, fx, mx
dw 0, 0, 20, 100  ; vy, ay, fy, my
dw 0, offset playerRect, 0, 0, 5, 30 ; pos, image, prev-pos, rotation, width, height
db 5*30 dup(0) ; background save place

ballController db 2
db PhysicsComponentId
db 5
db RenderComponentId
db 21
dw -64, 0, 0, 1000  ; vx, ax, fx, mx
dw -64, 0, 0, 1000  ; vy, ay, fy, my
dw 0, offset ballRect, 0, 0, 3, 3 ; pos, image, prev-pos, rotation, width, height
db 3*3 dup(0) ; background save place

borderUp db 1
db RenderComponentId
db 3
dw 0, 0, 0, 0, 320, 1 ; pos, image, prev-pos, rotation, width, height
db 320*1 dup(0) ; background save place

borderLeft db 1
db RenderComponentId
db 3
dw 0, 0, 0, 0, 1, 320 ; pos, image, prev-pos, rotation, width, height
db 320*1 dup(0) ; background save place

borderRight db 1
db RenderComponentId
db 3
dw 319, 0, 0, 0, 1, 320 ; pos, image, prev-pos, rotation, width, height
db 320*1 dup(0) ; background save place

borderDown db 1
db RenderComponentId
db 3
dw (199*320), 0, 0, 0, 320, 1 ; pos, image, prev-pos, rotation, width, height
db 320*1 dup(0) ; background save place

directionX dw 0
directionY dw 0

vector1 dw 0, 0
vector2 dw 0, 0
vector3 dw 0, 0
vector4 dw 0, 0
vector5 dw 0, 0

; *********************************OFFSET CONSTANTS*********************************

VideoMemory equ 0A000h

PhysicsComponentId            equ 4
PhysicsComponentAxisX         equ 0
PhysicsComponentVelocityX     equ 0
PhysicsComponentAccelerationX equ 2
PhysicsComponentFrictionX     equ 4
PhysicsComponentMaxVelocityX  equ 6
PhysicsComponentAxisY         equ 8
PhysicsComponentVelocityY     equ 8
PhysicsComponentAccelerationY equ 10
PhysicsComponentFrictionY     equ 12
PhysicsComponentMaxVelocityY  equ 14

; ********************************************

PhysicsComponentAxisVelocity     equ 0
PhysicsComponentAxisAcceleration equ 2
PhysicsComponentAxisFriction     equ 4
PhysicsComponentAxisMaxVelocity  equ 6

; ********************************************

AnimatorComponentId                    equ 3
AnimatorComponentCurrentAnimationIndex equ 0
AnimatorComponentCurrentFrameIndex     equ 1
AnimatorComponentAnimationAmount       equ 2
AnimatorComponentData                  equ 3

AnimationId         equ 2
AnimationSize       equ 1
AnimationSpeed      equ 2
AnimationData       equ 3

ArrayId              equ 8
ArraySize            equ 1
ArrayElementSize     equ 3
ArrayData            equ 5

Array2DId               equ 9
Array2DColumns          equ 1
Array2DRows             equ 3
Array2DElementSize      equ 5
Array2DData             equ 7

; ********************************************

RenderComponentId                  equ 1
RenderComponentPosition            equ 0
RenderComponentImage               equ 2
RenderComponentPreviousPosition    equ 4
RenderComponentRotation            equ 6
RenderComponentWidth               equ 8
RenderComponentHeight              equ 10
RenderComponentBackground          equ 12

; ********************************************

MouseComponentId equ 7
MouseComponentLeftClick  equ 0
MouseComponentRightClick equ 1

; ********************************************

ControllerMaxComponentAmount equ 0
ControllerComponentData      equ 1

ComponentId       equ 0
ComponentLocation equ 1

VectorX equ 0
VectorY equ 2

ImageId     equ 10
ImageWidth  equ 1
ImageHeight equ 3
ImageData   equ 5

RectId     equ 10
RectWidth  equ 1
RectHeight equ 3
RectColor  equ 5

PaletteLength equ 0
PaletteData   equ 2

PrintManagerId               equ 5
PrintManagerControllerAmount equ 1
PrintManagerData             equ 2

SegmentWrapperId       equ 6
SegmentWrapperSegment  equ 1
SegmentWrapperOriginal equ 3

; *********************************CONTROLLERS START********************************


; *********************************ANIMATIONS START********************************


; *********************************OBJECTS START********************************

KeyStateTable db 256 dup(0) ; Table to store key states (0 = released, 1 = pressed)

DirectionMultiplier equ 16*5
JumpHeight equ 16*4

SubPixelAmount equ 16

; *********************************GENERAL START********************************

animationTime dw 0
gameSpeed equ 40 ; in ms (to calculate FPS -> 1024 / FPS)
globalTime dw 0  ; in ms

; Declare variables to store the old ISR
oldKeyboardHandlerOffset dw ?
oldKeyboardHandlerSegment dw ?

; Save the original mask for restoration
previousIRQMask db ?

printManager db PrintManagerId, 0
dw 50 dup(0)

; segment screenBuffer
;     screen db 64000 dup(0)
; ends

; **********YOUR SHIT*********** ;

CODESEG

; input - Mouse pointer
proc initMouse
    push bp
    mov bp, sp
    push ax
    mov ax, 0 ; init Mouse
    int 33h
    push [bp + 4] ; mouse pointer
    push (100 * 320) + 160
    call initController
    pop ax
    pop bp
    ret 2
endp initMouse

proc updateMouse
    push bp
    mov bp, sp
    push bx
    push ax
    push si
    push dx
    push cx
    push di

    mov si, [bp + 6] ; Mouse pointer

    mov ax, 3 ; get mouse position cx - x, dx - y
    int 33h

    shr cx, 1 ; 0-639 -> 0-319
    cmp cx, 319 
    jne .skipFixX
    dec cx
.skipFixX:

    cmp dx, 199 
    jne .skipFixY
    dec dx
.skipFixY:

    mov ax, dx ;  compute screen position
    xor dx, dx
    mov di, 320
    mul di
    add ax, cx
    
    push si ; mouse controller
    push ax ; position
    ; call moveControllerByPosition

    push [bp + 4]
    push si
    call uploadController

    pop di
    pop cx
    pop dx
    pop si
    pop ax
    pop bx
    pop bp
    ret 4
endp updateMouse

proc keyboardHandler far              
	push ax
	push bx
    push cx
    push dx
	push di
	push si
	; read keyboard scan code
    in al, 60h

	; update keyboard state
    xor bh, bh
    mov bl, al
    and bl, 7Fh     ; bl = scan code
	
	; save to the keyboard array
    push cx
	mov cx, 7
    shr al, cl ; al = 0 if pressed, 1 if released
	pop cx
    xor al, 1  ; al = 1 if pressed, 0 if released
    mov [cs:KeyStateTable + bx], al  ; save pressed buttons in array
	
	; send EOI to XT keyboard
    in  al, 61h
    mov ah, al
    or  al, 80h
    out 61h, al
    mov al, ah
    out 61h, al

	; send EOI to master PIC
    mov al, 20h
    out 20h, al
	
    pop si
    pop di
    pop dx
    pop cx
    pop bx
    pop ax
    iret
endp keyboardHandler

; interrupt that hooks on to int70h
; that is called by the computer
; and call the "periodic" method 1024 times a sec
proc clock far
    push bp
    mov bp, sp
    push ax
    push bx
    push dx
    push ds
    ; Preserve port 70h contents
    in al, 70h
    mov bx, ax
    ; Read status register C to acknowledge RTC interrupt
    mov al, 0Ch
    out 70h, al
    mov al, 8Ch
    out 70h, al
    in al, 71h
    ; Restore port 70h contents
    mov ax, bx
    out 70h, al
    ; Notify PICs that interrupt is handled
    mov al, 20h
    out 0A0h, al
    out 020h, al
    push offset globalTime
    call periodic ; every tick (1024 times a sec)
    pop ds
    pop dx
    pop bx
    pop ax
    pop bp
    iret
endp clock

; setup the game clock
proc setUpClock
    push bp
    mov bp, sp
    push ax
    push ds
    push dx

    cli
    ; Save original mask of secondary PIC
    in al, 0A1h
    mov [bp + 4], al
    and al, 0FEh ; Enable IRQ 8 (RTC)
    out 0A1h, al

    ; Set frequency divisor in RTC register A
    mov al, 0Ah
    out 70h, al
    mov al, 8Ah
    out 70h, al
    in al, 71h
    and al, 11110000b ; Clear rate bits
    or al, 0110b      ; Set rate to 1024 Hz
    out 71h, al
    in al, 71h        ; Ensure the write is complete

    ; Enable periodic interrupts in RTC register B
    mov al, 0Bh
    out 70h, al
    mov al, 8Bh
    out 70h, al
    in al, 71h
    or al, 40h        ; Set PI (bit 6)
    out 71h, al
    in al, 71h        ; Acknowledge the change

    ; Set new interrupt handler for interrupt 70h
    mov al, 70h       ; Interrupt vector 70h
    mov ah, 25h       ; Set interrupt vector
    mov dx, offset clock ; Offset of the ISR
    push seg clock
    pop ds
    int 21h
    sti

    pop dx
    pop ds
    pop ax
    pop bp
    ret 2
endp setUpClock

; clean up the game's clock
proc cleanUpClock
    push bp
    mov bp, sp
    push ax
    ; Restore original mask of secondary PIC
    mov al, [bp + 4] ; mask pointer
    out 0A1h, al
    pop ax
    pop bp
    ret 2
endp cleanUpClock

; ***********************GENERAL GETTERS*********************

proc getControllerWordValue
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 8] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov bx, [bx]
    mov [bp + 8], bx
    pop bx
    pop bp
    ret 4
endp getControllerWordValue

proc getControllerWordOffset
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 8] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov [bp + 8], bx
    pop bx
    pop bp
    ret 4
endp getControllerWordOffset

proc getControllerByteValue
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 8] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov bl, [bx]
    mov [bp + 8], bl
    pop bx
    pop bp
    ret 4
endp getControllerByteValue

; ***********************GENERAL SETTERS*********************

proc setControllerWordValue
    push bp
    mov bp, sp
    push ax
    push bx
    mov bx, [bp + 10] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov ax, [bp + 8] ; value
    mov [bx], ax
    pop bx
    pop ax
    pop bp
    ret 8
endp setControllerWordValue

proc addControllerWordValue
    push bp
    mov bp, sp
    push ax
    push bx
    mov bx, [bp + 10] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov ax, [bp + 8] ; addition
    add [bx], ax
    pop bx
    pop ax
    pop bp
    ret 8
endp addControllerWordValue

proc setControllerByteValue
    push bp
    mov bp, sp
    push ax
    push bx
    mov bx, [bp + 10] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov al, [bp + 8] ; value
    mov [bx], al
    pop bx
    pop ax
    pop bp
    ret 8
endp setControllerByteValue

proc addControllerByteValue
    push bp
    mov bp, sp
    push ax
    push bx
    mov bx, [bp + 10] ; controller pointer
    push bx
    push [bp + 6] ; componentId
    call getControllerComponent
    pop bx
    add bx, [bp + 4] ; parameter
    mov al, [bp + 8] ; addition
    add [bx], al
    pop bx
    pop ax
    pop bp
    ret 8
endp addControllerByteValue

; ****************************************

; input - word directionX pointer, word directionY pointer
proc updateDirection
    push bp
    mov bp, sp
    push ax
    push si
    push di
    mov si, [bp + 6]  ; directionX pointer
    mov di, [bp + 4]  ; directionY pointer
    mov [word ptr si], 0
    mov [word ptr di], 0
    cmp [byte ptr KeyStateTable + 1Eh], 1 ; Check if 'A' key is pressed (scan code 1Eh)
    je .setLeft
    cmp [byte ptr KeyStateTable + 20h], 1  ; Check if 'D' key is pressed (scan code 20h)
    je .setRight
    jmp .checkY
.setLeft:
    mov [word ptr si], -1 * DirectionMultiplier
    jmp .checkY
.setRight:
    mov [word ptr si], DirectionMultiplier
.checkY:
    cmp [byte ptr KeyStateTable + 11h], 1 ; Check if 'W' key is pressed (scan code 11h)
    je .setUp
    cmp [byte ptr KeyStateTable + 1Fh], 1 ; Check if 'S' key is pressed (scan code 1Fh)
    je .setDown
    jmp .end
.setUp:
    mov [word ptr di], -1 * DirectionMultiplier
    jmp .end
.setDown:
    mov [word ptr di], DirectionMultiplier
.end:
    pop di
    pop si
    pop ax
    pop bp
    ret 4
endp updateDirection

; clears the screen (turns all pixels to 0)
proc clearScreen
    push di
    push ax
    push es
    mov ax, VideoMemory
    mov es, ax
    mov di, 64001
.clearLoop:
    dec di
    mov [byte ptr es:di], 0
    jnz .clearLoop
    pop es
    pop ax
    pop di
    ret
endp clearScreen

; input - palette pointer
; sets it to the screen's palette
proc setPalette
    push bp
    mov bp, sp
    push ax
    push si
    push cx
    push dx
	mov si, [bp + 4]
	mov cx, [si + PaletteLength]
    add si, PaletteData
	mov dx, 3C8h
	mov al, 0
	out dx, al ; copy starting color to port 3C8h
	inc dx     ; copy palette itself to port 3C9h
.setLoop:
	mov al, [si]   ; red
	out dx, al
	mov al, [si + 1] ; green
	out dx, al
	mov al, [si + 2] ; blue
	out dx, al
	add si, 3      ; move to next color
	loop .setLoop
    pop dx
    pop cx
    pop si
    pop ax
    pop bp
	ret 2
endp setPalette

; input - current pixel pos
; output - (ah = 0/1 x border) (al = 0/1 y border)
proc checkImageBorders
    push bp
    mov bp, sp
    push ax
    push cx
    push dx
    push bx

    xor bx, bx
    mov ax, [bp + 4]  ; current pos

    mov cx, 320
    xor dx, dx
    idiv cx ; ax - y, dx - x
    cmp dx, 319
    je .setTrueX
    cmp ax, 199
    je .setTrueY

    jmp .end
.setTrueX:
    mov bh, 1
    jmp .end
.setTrueY:
    mov bl, 1
.end:
    mov [bp + 4], bx
    pop bx
    pop dx
    pop cx
    pop ax
    pop bp
    ret
endp checkImageBorders

proc printRect
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 6] ; rect pointer
    push [bx + RectColor]
    push [bx + RectWidth]
    push [bx + RectHeight]
    push [bp + 4] ; screen position (left top)
    call printRectBySize
    pop bx
    pop bp
    ret 4
    ret
endp printRect

proc checkBoundaries
    push bp
    mov bp, sp
    push ax
    push dx
    push bx
    push cx
    push si

    mov bx, [bp + 8] ; width
    mov si, [bp + 6] ; height
    mov ax, [bp + 4] ; position

    mov cx, 320
    xor dx, dx
    idiv cx ; ax = y ; dx = x

    cmp ax, 200
    jl .skip
    mov cx, -1
.skip:

    add dx, bx
    cmp dx, 320
    jl .skipWidthFix

    sub dx, 320
    sub bx, dx

.skipWidthFix:
    add ax, si
    cmp ax, 200
    jl .end

    sub ax, 200
    sub si, ax

.end:
    mov [bp + 8], cx
    mov [bp + 6], bx
    mov [bp + 4], si

    pop si
    pop cx
    pop bx
    pop dx
    pop ax
    pop bp
    ret
endp checkBoundaries

proc printRectBySize
    push bp
    mov bp, sp
    push di
    push ax
    push bx
    push cx
    push dx
    push si
    push es
    mov ax, VideoMemory
    mov es, ax
    mov bx, [bp + 10] ; color
    mov dx, [bp + 8]  ; width
    mov cx, [bp + 6]  ; height
    mov di, [bp + 4]  ; screen position (left top)

    push dx
    push cx
    push di
    call checkBoundaries
    pop cx
    pop dx
    pop ax

    cmp ax, -1
    je .end

    mov si, 0 ; reset width counter
    cmp bl, -1
    je .end
.printLoop:
    je .skipPixel ; skip if it's empty (-1)
    mov [byte ptr es:di], bl
.skipPixel:
    inc di ; move to the next pixel from screen
    inc si ; inc the current width counter
    cmp si, dx ; if reached end of the row
    jne .printLoop
.nextRow:
    add di, 320
    sub di, dx ; point to the next column
    xor si, si ; reset width counter
    dec cx
    jnz .printLoop
.end:
    pop es
    pop si
    pop dx
    pop cx
    pop bx
    pop ax
    pop di
    pop bp
    ret 8
endp printRectBySize

proc printImageBySize
    push bp
    mov bp, sp
    push di
    push ax
    push bx
    push cx
    push dx
    push si
    push es
    mov ax, VideoMemory
    mov es, ax
    mov bx, [bp + 10] ; color array pointer
    mov cx, [bp + 8]  ; height
    mov dx, [bp + 6]  ; width
    mov di, [bp + 4]  ; screen position (left top)

    push dx
    push cx
    push di
    call checkBoundaries
    pop cx
    pop dx
    pop ax

    cmp ax, -1
    je .end

    mov si, 0 ; reset width counter
.printLoop:
    mov al, [byte ptr bx] ; get the color
    cmp al, -1
    je .skipPixel ; skip if it's empty (-1)
    mov [byte ptr es:di], al
.skipPixel:
    inc di ; move to the next pixel from screen
    inc bx ; move to the next pixel from image
    inc si ; inc the current width counter
    cmp si, dx ; if reached end of the row
    jne .printLoop
.nextRow:
    add di, 320
    sub di, dx ; point to the next column
    xor si, si ; reset width counter
    dec cx
    jnz .printLoop
.end:
    pop es
    pop si
    pop dx
    pop cx
    pop bx
    pop ax
    pop di
    pop bp
    ret 8
endp printImageBySize

; input - image pointer, position (left top corner)
; prints the image at the specified location
proc printImage
    push bp
    mov bp, sp
    push ax
    push bx
    mov bx, [bp + 6] ; image pointer
    mov ax, bx
    add ax, ImageData
    push ax ; image data (colors)
    push [bx + ImageHeight]
    push [bx + ImageWidth]
    push [bp + 4] ; screen position (left top)
    call printImageBySize
    pop bx
    pop ax
    pop bp
    ret 4
endp printImage

; input - controller pointer
; prints it to the screen
proc printController
    push bp
    mov bp, sp
    push di
    push bx
    mov di, [bp + 4] ; controller pointer
    push di
    push RenderComponentId
    call getControllerComponent
    pop di ; component

    mov bx, [di + RenderComponentImage]
    mov bl, [bx]

    cmp bl, RectId
    jz .isRect
    cmp bl, ImageId
    jz .isImage
    cmp bl, ArrayId
    jz .isArray

    jmp .end
.isRect:
    push [word ptr di + RenderComponentImage]
    push [word ptr di + RenderComponentPosition]
    call printRect
    jmp .end
.isArray:
    push [word ptr di + RenderComponentImage]
    push [word ptr di + RenderComponentRotation]
    call getArrayElement
    push [word ptr di + RenderComponentPosition]
    call printImage
    jmp .end
.isImage:
    push [word ptr di + RenderComponentImage]
    push [word ptr di + RenderComponentPosition]
    call printImage
.end:
    pop bx
    pop di
    pop bp
    ret 2
endp printController

; saves the background to the controller so it could move
; without affecting the background
proc saveController
    push bp
    mov bp, sp
    push di
    push bx
    push cx
    push dx
    push si
    push ax
    push es
    mov ax, VideoMemory
    mov es, ax
    mov di, [bp + 4]  ; controller
    push di
    push RenderComponentId
    call getControllerComponent
    pop di ; component

    mov bx, di
    add bx, RenderComponentBackground

    mov cx, [di + RenderComponentHeight]
    mov dx, [di + RenderComponentWidth]
    mov di, [di + RenderComponentPosition]
    mov si, 0  ; width counter
.saveLoop:
    mov al, [es:di]
    mov [bx], al
    inc di
    inc bx
    inc si
    cmp si, dx ; if reached end of the row
    jne .saveLoop
    add di, 320
    sub di, dx ; point to the next column
    xor si, si
    dec cx
    jnz .saveLoop
    pop es
    pop ax
    pop si
    pop dx
    pop cx
    pop bx
    pop di
    pop bp
    ret 2
endp saveController

proc printBackground
    push bp
    mov bp, sp
    push di
    push dx
    mov di, [bp + 4] ; controller pointer

    push di
    push RenderComponentId
    call getControllerComponent
    pop di ; component

    mov dx, di
    add dx, RenderComponentBackground
    push dx ; to give its location, and not its value
    push [di + RenderComponentHeight]
    push [di + RenderComponentWidth]
    push [di + RenderComponentPreviousPosition]
    call printImageBySize

    mov dx, [di + RenderComponentPosition]
    mov [di + RenderComponentPreviousPosition], dx

    pop dx
    pop di
    pop bp
    ret 2
endp printBackground

; input - controller pointer, word init position
; init the controller to the set position (saves the background, prints and moves to the location)
proc initController
    push bp
    mov bp, sp
    push di
    push ax
    push bx
    mov di, [bp + 6] ; controller pointer
    mov ax, [bp + 4] ; set position

    push di
    push RenderComponentId
    call getControllerComponent
    pop bx ; component

    mov [bx + RenderComponentPosition], ax
    mov [bx + RenderComponentPreviousPosition], ax
    
    push di
    call saveController
    push di
    call printController
    pop bx
    pop ax
    pop di
    pop bp
    ret 4
endp initController

; input - animated controller pointer
; moves the current animation a frame (if last frame resets it)
proc moveToNextAnimationFrame
    push bp
    mov bp, sp
    push di
    push bx
    push ax
    mov di, [bp + 4] ; controller pointer
    xor ax, ax
    push di
    call getCurrentAnimation
    pop bx ; current animation
    push di
    push AnimatorComponentId
    call getControllerComponent
    pop di ; component
    mov bl, [bx + AnimationSize]    ; animation size
    mov al, [di + AnimatorComponentCurrentFrameIndex] ; current frame number
    inc al                                       ; next frame
    cmp al, bl
    jne .end
    mov al, 0
.end:
    mov [di + AnimatorComponentCurrentFrameIndex], al ; set the frame
    pop ax
    pop bx
    pop di
    pop bp
    ret 2
endp moveToNextAnimationFrame

; input - controller pointer, byte animation number
; sets the current animation by number (first is 0, second is 1...)
proc setAnimation
    push bp
    mov bp, sp
    push di
    push ax
    xor ax, ax
    mov al, [bp + 4] ; animation number
    mov di, [bp + 6] ; controller pointer
    push di
    push AnimatorComponentId
    call getControllerComponent
    pop di ; animator component
    mov [byte ptr di + AnimatorComponentCurrentAnimationIndex], al  ; set current animation
    mov [byte ptr di + AnimatorComponentCurrentFrameIndex], 0       ; set current frame 0
    pop ax
    pop di
    pop bp
    ret 4
endp setAnimation

proc getFrameImage
    push bp
    mov bp, sp
    push bx
    push si

    mov bx, [bp + 6] ; animation
    mov si, [bp + 4] ; frame index

    add bx, AnimationData ; first animation
    add bx, si
    add bx, si ; current animation (every anim is a word)

    mov bx, [bx]
    mov [bp + 6], bx

    pop si
    pop bx
    pop bp
    ret 2
endp getFrameImage

; input - animated controller, current time (0-255)
; updates it's current animation
proc updateAnimation
    push bp
    mov bp, sp
    push ax
    push bx
    push di
    push cx
    mov di, [bp + 6] ; controller pointer
    mov al, [bp + 4] ; current time

    push di
    call getCurrentAnimation
    pop bx
    
    mov ch, [bx + AnimationSpeed] ; animation speed
    div ch ; ah - time % speed
    cmp ah, 0
    jne .end

    push di
    call moveToNextAnimationFrame

    push di
    push AnimatorComponentId
    push AnimatorComponentCurrentFrameIndex
    call getControllerByteValue
    pop cx
    mov ch, 0 ; cl = current frame index

    push bx
    push cx
    call getFrameImage
    pop bx

    push di
    push bx
    push RenderComponentId
    push RenderComponentImage
    call setControllerWordValue

.end:
    pop cx
    pop di
    pop bx
    pop ax
    pop bp
    ret 4
endp updateAnimation

; updates animation time
proc updateAnimationTime
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 4]    ; time pointer
    cmp [byte ptr bx], 255
    jne .continue
    mov [byte ptr bx], 0
.continue:
    inc [byte ptr bx]
    pop bx
    pop bp
    ret 2
endp updateAnimationTime

; proc printScreenBuffer
;     push bp
;     mov bp, sp
;     push ds
;     push di
;     push ax
;     push es
;     mov ax, VideoMemory
;     mov es, ax
;     mov ax, [bp + 4] ; buffer segment
;     mov ds, ax

;     mov di, 0
; .printLoop:
;     mov al, [di]
;     mov [byte ptr es:di], al

;     inc di
;     cmp di, 64001
;     jnz .printLoop


;     pop es
;     pop ax
;     pop di
;     pop ds
;     pop bp
;     ret 2
; endp printScreenBuffer

; input - printManager pointer
; prints all the controllers
proc printAllControllers
    push bp
    mov bp, sp
    push bx
    push cx
    push si
    mov si, [bp + 4] ; offset printManager
    add si, PrintManagerControllerAmount
    mov bx, si
    mov cl, [byte ptr bx] ; amount of controllers
.printBackgroundLoop:
    cmp cl, 0
    je .printBackgroundEnd
    push [bx + 1]      ; controller pointer
    call printBackground
    add bx, 2
    dec cl
    jmp .printBackgroundLoop
.printBackgroundEnd:
    mov bx, si
    mov cl, [byte ptr bx] ; amount of controllers
.saveLoop:
    cmp cl, 0
    je .saveEnd
    push [bx + 1]      ; controller pointer
    call saveController
    add bx, 2
    dec cl
    jmp .saveLoop
.saveEnd:
    mov bx, si
    mov cl, [byte ptr bx] ; amount of controllers
    mov [byte ptr bx], 0
.printImageLoop:
    cmp cl, 0
    je .end
    push [bx + 1]      ;  controller pointer
    call printController
    mov [word ptr bx + 1], 0
    add bx, 2
    dec cl
    jmp .printImageLoop
.end:
    pop si
    pop cx
    pop bx
    pop bp
    ret 2
endp printAllControllers

; input - printManager pointer, controller pointer
; uploads the controller to the manager
proc uploadController
    push bp
    mov bp, sp
    push bx
    push di
    push ax
    mov bx, [bp + 6] ; printManager pointer
    mov di, [bp + 4] ; controller pointer
    xor ax, ax
    mov al, [byte ptr bx + PrintManagerControllerAmount] ; amount of controllers
    inc [byte ptr bx + PrintManagerControllerAmount]     ; inc the amount of controllers
    shl ax, 1 ; every pointer is a word
    add bx, ax
    mov [bx + PrintManagerData], di  ; upload it
    pop ax
    pop di
    pop bx
    pop bp
    ret 4
endp uploadController

; input - animated controller
; returns the current animation
proc getCurrentAnimation
    push bp
    mov bp, sp
    push di
    push bx
    mov di, [bp + 4] ; controller pointer

    push di
    push AnimatorComponentId
    call getControllerComponent
    pop di ; component

    xor bx, bx
    mov bl, [di + AnimatorComponentCurrentAnimationIndex]  ; current animation index
    add di, AnimatorComponentData ; animation list
    shl bx, 1                     ; each animation is a word         
    add di, bx                    ; current animation
    mov di, [di]                  ; get the pointer to anim and not the pointer to the pointer
    mov [bp + 4], di

    pop bx
    pop di
    pop bp
    ret
endp getCurrentAnimation

; input - velocity controller
; update its velocity (x and y)
proc updateVelocity
    push bp
    mov bp, sp
    push bx
    push ax
    mov bx, [bp + 4] ; controller

    push bx
    push PhysicsComponentId
    call getControllerComponent
    pop bx ; component

    mov ax, bx
    add ax, PhysicsComponentAxisX
    push ax
    call updatePhysicsAxis      ; update x axis

    mov ax, bx
    add ax, PhysicsComponentAxisY
    push ax
    call updatePhysicsAxis      ; update y axis

    pop ax
    pop bx
    pop bp
    ret 2
endp updateVelocity

; input - velocity axis (start of each axis part)
; updates its velocity
proc updatePhysicsAxis
    push bp
    mov bp, sp
    push bx
    push dx
    push si
    push cx
    mov si, [bp + 4]                                ; physics axis
    mov dx, [si + PhysicsComponentAxisFriction]     ; friction
    mov bx, [si + PhysicsComponentAxisVelocity]     ; velocity
    mov cx, [si + PhysicsComponentAxisMaxVelocity]  ; max velocity
    cmp bx, 0
    jl .positiveFriction ; if we go negative
    cmp bx, 0
    jg .negativeFriction ; if we go negative

    mov bx, [si + PhysicsComponentAxisAcceleration] ; accerlation
    add [si], bx                                    ; add velocity acceleration

    jmp .end
.negativeFriction:
    sub bx, dx ; check if the gravity is too much it will become positive, if so reset it
    cmp bx, 0
    jl .resetFriction
    sub [si + PhysicsComponentAxisVelocity], dx

    mov bx, [si + PhysicsComponentAxisAcceleration] ; accerlation
    add [si], bx                                    ; add velocity acceleration

    jmp .limitPositiveVelocity
.positiveFriction:
    add bx, dx ; check if the gravity is too much it will become negative, if so reset it
    cmp bx, 0
    jg .resetFriction
    add [si + PhysicsComponentAxisVelocity], dx
    
    mov bx, [si + PhysicsComponentAxisAcceleration] ; accerlation
    add [si], bx                                    ; add velocity acceleration

    jmp .limitNegativeVelocity
.resetFriction:
    mov [word ptr si + PhysicsComponentAxisVelocity], 0
    jmp .end
.limitPositiveVelocity:
    cmp [si + PhysicsComponentAxisVelocity], cx
    jl .limitNegativeVelocity
    mov [si + PhysicsComponentAxisVelocity], cx
.limitNegativeVelocity:
    neg cx
    cmp [si + PhysicsComponentAxisVelocity], cx
    jg .end
    mov [si + PhysicsComponentAxisVelocity], cx
.end:
    pop cx
    pop si
    pop dx
    pop bx
    pop bp
    ret 2
endp updatePhysicsAxis

; input - value min max
; returns the clamp of a value by: max(minimum, min(x, maximum))
proc getClamp
    push bp
    mov bp, sp
    push ax

    push [bp + 6] ; min

    push [bp + 8] ; value
    push [bp + 4] ; max
    call getMin
    call getMax
    pop ax
    mov [bp + 8], ax

    pop ax
    pop bp
    ret 4
endp getClamp

; input - physics controller
; adds the velocity to the controllers using the subPixelAmount
; const to enable sub-pixel movement, for example - 0.5 pixels/frame
proc applyVelocity
    push bp
    mov bp, sp
    push bx
    push ax
    push di
    push dx
    push cx

    mov bx, [bp + 4] ; controller

    push bx
    push PhysicsComponentId
    call getControllerComponent
    pop di ; physics component

    push bx
    push RenderComponentId
    call getControllerComponent
    pop bx ; render component

    push 0
    push [bx + RenderComponentPosition]
    call getXandY
    pop cx ; x
    pop dx ; y

    push [di + PhysicsComponentVelocityY]
    push SubPixelAmount
    call divide
    pop ax     ; y add
    add dx, ax ; dx new y

    push [di + PhysicsComponentVelocityX]
    push SubPixelAmount
    call divide
    pop ax     ; x add
    add cx, ax ; cx new x

    mov ax, 320
    sub ax, [bx + RenderComponentWidth]

    push cx ; new x
    push 0
    push ax
    call getClamp
    pop cx

    mov ax, 200
    sub ax, [bx + RenderComponentHeight]

    push dx ; new y
    push 0
    push ax
    call getClamp
    pop dx

    push cx ; x
    push dx ; y
    call getPositionFromXandY ; new position
    pop [bx + RenderComponentPosition]

    pop cx
    pop dx
    pop di
    pop ax
    pop bx
    pop bp
    ret 2
endp applyVelocity

proc updateAndApplyVelocity
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 4] ; controller
    push bx
    call updateVelocity
    push bx
    call applyVelocity
    pop bx
    pop bp
    ret 2
endp updateAndApplyVelocity

proc walk
    push bp
    mov bp, sp
    push ax
    push bx
    mov bx, [bp + 6] ; controller
    mov ax, [bp + 4] ; direction X
    cmp ax, 0
    je .skipX
    push bx
    push ax
    push PhysicsComponentId
    push PhysicsComponentVelocityX
    call setControllerWordValue
.skipX:
    pop bx
    pop ax
    pop bp
    ret 4
endp walk

proc move2d
    push bp
    mov bp, sp
    push ax
    push bx
    push dx
    mov bx, [bp + 8] ; controller
    mov ax, [bp + 6] ; direction X
    mov dx, [bp + 4] ; direction Y

    cmp ax, 0
    je .skipX

    push bx
    push ax
    push PhysicsComponentId
    push PhysicsComponentVelocityX
    call setControllerWordValue
.skipX:

    cmp dx, 0
    je .skipY

    push bx
    push dx
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
.skipY:

    pop dx
    pop bx
    pop ax
    pop bp
    ret 6
endp move2d   

proc jump
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 4] ; controller
    cmp [byte ptr KeyStateTable + 39h], 0 ; space scan code
    je .end
    push bx
    push -1 * JumpHeight
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
.end:
    pop bx
    pop bp
    ret 2
endp jump

proc getControllerY
    push bp
    mov bp, sp
    push ax
    push bx
    push dx
    mov bx, [bp + 4] ; first controller
    push bx
    push RenderComponentId
    push RenderComponentPosition
    call getControllerWordValue
    pop ax
    mov bx, 320
    xor dx, dx
    div bx
    mov [bp + 4], ax ; y
    pop dx
    pop bx
    pop ax
    pop bp
    ret
endp getControllerY

proc getControllerX
    push bp
    mov bp, sp
    push ax
    push bx
    push dx
    mov bx, [bp + 4] ; first controller
    push bx
    push RenderComponentId
    push RenderComponentPosition
    call getControllerWordValue
    pop ax
    mov bx, 320
    xor dx, dx
    div bx
    mov [bp + 4], dx ; x
    pop dx
    pop bx
    pop ax
    pop bp
    ret
endp getControllerX

proc getControllerYEdges
    push bp
    mov bp, sp
    push ax
    push bx
    push dx
    push di
    mov bx, [bp + 4] ; controller
    push bx
    call getControllerY
    pop ax ; top
    push bx
    push RenderComponentId
    push RenderComponentHeight
    call getControllerWordValue
    pop di
    mov dx, ax
    add dx, di       ; bottom
    mov [bp + 6], ax
    mov [bp + 4], dx
    pop di
    pop dx
    pop bx
    pop ax
    pop bp
    ret
endp getControllerYEdges

proc getControllerXEdges
    push bp
    mov bp, sp
    push ax
    push bx
    push dx
    push di
    mov bx, [bp + 4] ; controller
    push bx
    call getControllerX
    pop ax ; left
    push bx
    push RenderComponentId
    push RenderComponentWidth
    call getControllerWordValue
    pop di
    mov dx, ax
    add dx, di       ; right
    mov [bp + 6], ax
    mov [bp + 4], dx
    pop di
    pop dx
    pop bx
    pop ax
    pop bp
    ret
endp getControllerXEdges

; return the difference in the Y axis between two objects
; input - first controller, second controller
proc isYCollision
    push bp
    mov bp, sp
    push ax
    push bx
    push si
    push di
    push dx
    mov si, [bp + 4] ; first controller
    mov bx, [bp + 6] ; second controller

    push 0 ; garbage value
    push si
    call getControllerYEdges
    pop ax
    pop dx

    push 0 ; garbage value
    push bx
    call getControllerYEdges
    pop bx
    pop si

    push ax
    push dx
    push bx
    push si
    call isAxisCollisionSquare
    pop ax
    mov [bp + 6], ax

    pop dx
    pop di
    pop si
    pop bx
    pop ax
    pop bp
    ret 2
endp isYCollision

; return the difference in the X axis between two objects
; input - first controller, second controller
proc isXCollision
    push bp
    mov bp, sp
    push ax
    push bx
    push si
    push di
    push dx
    mov si, [bp + 4] ; first controller
    mov bx, [bp + 6] ; second controller

    push 0 ; garbage value
    push si
    call getControllerXEdges
    pop ax
    pop dx

    push 0 ; garbage value
    push bx
    call getControllerXEdges
    pop bx
    pop si

    push ax
    push dx
    push bx
    push si
    call isAxisCollisionSquare
    pop ax
    mov [bp + 6], ax

    pop dx
    pop di
    pop si
    pop bx
    pop ax
    pop bp
    ret 2
endp isXCollision

proc getAbsValue
    push bp
    mov bp, sp
    push ax
    mov ax, [bp + 4]
    cmp ax, 0    ; check if positive
    jge .end     ; if greater than or equal to 0, jump to end
    neg ax       ; negate to get the absolute value
.end:
    mov [bp + 4], ax
    pop ax
    pop bp
    ret
endp getAbsValue

proc getXandY
    push bp
    mov bp, sp
    push ax
    push dx
    push cx

    mov ax, [bp + 4] ; position
    mov cx, 320
    xor dx, dx
    idiv cx ; ax = y ; dx = x

    mov [bp + 4], dx
    mov [bp + 6], ax

    pop cx
    pop dx
    pop ax
    pop bp
    ret
endp getXandY

proc isAxisCollisionPoint
    push bp
    mov bp, sp
    push bx
    push cx
    push ax

    mov bx, [bp + 8] ; controller x
    mov cx, [bp + 6] ; controller width
    mov ax, [bp + 4] ; point x

    cmp ax, bx ; point x < controller x
    jl .setFalse

    add bx, cx       ; bx = squareX + squareWidth
    cmp ax, bx       ; if pointY > squareY + squareHeight
    jg .setFalse

    mov ax, 1
    jmp .end

.setFalse:
    mov ax, 0
.end:
    mov [bp + 8], ax

    pop ax
    pop cx
    pop bx
    pop bp
    ret 4
endp isAxisCollisionPoint

proc doesPointCollideController
    push bp
    mov bp, sp
    push bx
    push si
    push ax
    push cx
    push dx
    push di

    mov bx, [bp + 6] ; controller
    mov si, [bp + 4] ; point

    push bx
    push RenderComponentId
    call getControllerComponent
    pop bx ; render component

    cmp [bx + RenderComponentPosition], si
    jg .setFalse

    push 0
    push si
    call getXandY
    pop ax ; point x
    pop dx ; point y

    push 0
    push [bx + RenderComponentPosition]
    call getXandY
    pop cx ; controller x
    pop si ; controller y

    push cx                          ; controller x
    push [bx + RenderComponentWidth] ; width
    push ax                          ; point x
    call isAxisCollisionPoint
    pop ax                           ; if there's collision
    cmp ax, 0
    jz .setFalse

    push si                           ; controller y
    push [bx + RenderComponentHeight] ; height
    push dx                           ; point y
    call isAxisCollisionPoint
    pop ax                            ; if there's collision
    cmp ax, 0
    jz .setFalse

    mov ax, 1 ; if both tests passed
    jmp .end

.setFalse:
    mov ax, 0
.end:
    mov [bp + 6], ax

    pop di
    pop dx
    pop cx
    pop ax
    pop si
    pop bx
    pop bp
    ret 2
endp doesPointCollideController

proc getPositionFromXandY
    push bp
    mov bp, sp
    push ax
    push dx
    push cx
    push bx

    mov bx, [bp + 6] ; x
    mov ax, [bp + 4] ; y

    mov cx, 320
    xor dx, dx
    imul cx ; ax = y * 320
    add ax, bx

    mov [bp + 6], ax

    pop bx
    pop cx
    pop dx
    pop ax
    pop bp
    ret 2
endp getPositionFromXandY

proc getElements
    push bp
    mov bp, sp
    push dx
    push cx
    push ax

    push 0
    push [bp + 6]
    call getXandY
    pop dx ; x
    pop cx ; y

    push 0
    push [bp + 4]
    call getXandY
    pop ax ; x
    sub dx, ax ; dx - diff x
    pop ax ; y
    sub cx, ax ; cx - diff y

    push dx ; diff x
    push cx ; diff y
    call getMaxAbs
    pop ax ; amount of steps

    mov [bp + 4], dx ; diff x
    mov [bp + 6], cx ; diff y
    mov [bp + 8], ax ; amount of steps

    pop ax
    pop cx
    pop dx
    pop bp
    ret
endp getElements

proc areControllersColliding
    push bp
    mov bp, sp
    push ax
    push bx
    push si
    push cx
    push di
    push dx

    mov si, [bp + 6] ; controller
    mov bx, [bp + 4] ; collider

    push si
    push RenderComponentId
    call getControllerComponent
    pop di

    push 0
    push [di + RenderComponentPosition]
    push [di + RenderComponentPreviousPosition]
    call getElements
    pop dx ; diff x
    pop cx ; diff y
    pop ax ; amount of steps

    cmp ax, 0
    jne .skipFrameRaycast
    push si
    push bx
    call areControllersCollidingThisFrame
    pop dx
    jmp .end
.skipFrameRaycast:

    push dx ; diff x
    push ax ; amount of steps
    call divide
    pop dx ; step x

    push cx ; diff y
    push ax ; amount of steps
    call divide
    push 320
    call multiply
    pop cx ; step y

    add cx, dx ; diff (x + y)

    push bx

    mov bx, [di + RenderComponentPreviousPosition]
    mov [di + RenderComponentPosition], bx

    pop bx ; we start from previous position

.startLoop:
    add [di + RenderComponentPosition], cx ; add diff

    push si
    push bx
    call areControllersCollidingThisFrame
    pop dx

    cmp dx, 0
    jne .end

    dec ax ; amount of steps
    jnz .startLoop

.end:
    mov [bp + 6], dx
    pop dx
    pop di
    pop cx
    pop si
    pop bx
    pop ax
    pop bp
    ret 2
endp areControllersColliding

proc getMin
    push bp
    mov bp, sp
    push bx
    push dx

    mov bx, [bp + 4] ; value1
    mov dx, [bp + 6] ; value2

    cmp bx, dx
    jg .end
    mov dx, bx
.end:
    mov [bp + 6], dx

    pop dx
    pop bx
    pop bp
    ret 2
endp getMin

proc getMax
   push bp
    mov bp, sp
    push bx
    push dx

    mov bx, [bp + 4] ; value1
    mov dx, [bp + 6] ; value2

    cmp bx, dx
    jl .end
    mov dx, bx
.end:
    mov [bp + 6], dx

    pop dx
    pop bx
    pop bp
    ret 2
endp getMax

proc getMinAbs
   push bp
    mov bp, sp
    push bx
    push dx

    mov bx, [bp + 4] ; value1
    mov dx, [bp + 6] ; value2

    push bx
    call getAbsValue
    pop bx
    
    push dx
    call getAbsValue
    pop dx

    cmp bx, dx
    jg .end
    mov dx, bx
.end:
    mov [bp + 6], dx

    pop dx
    pop bx
    pop bp
    ret 2
endp getMinAbs

proc getMaxAbsIndex
    push bp
    mov bp, sp
    push bx
    push dx

    mov bx, [bp + 4] ; value1
    mov dx, [bp + 6] ; value2

    push bx
    call getAbsValue
    pop bx
    
    push dx
    call getAbsValue
    pop dx

    cmp bx, dx
    jl .continue
    mov dx, 1
    jmp .end
.continue:
    mov dx, 0
.end:
    mov [bp + 6], dx

    pop dx
    pop bx
    pop bp
    ret 2
endp getMaxAbsIndex

proc getMinAbsIndex
    push bp
    mov bp, sp
    push bx
    push dx

    mov bx, [bp + 4] ; value1
    mov dx, [bp + 6] ; value2

    push bx
    call getAbsValue
    pop bx
    
    push dx
    call getAbsValue
    pop dx

    cmp bx, dx
    jg .continue
    mov dx, 1
    jmp .end
.continue:
    mov dx, 0
.end:
    mov [bp + 6], dx

    pop dx
    pop bx
    pop bp
    ret 2
endp getMinAbsIndex

proc getMaxAbs
    push bp
    mov bp, sp
    push bx
    push dx

    mov bx, [bp + 4] ; value1
    mov dx, [bp + 6] ; value2

    push bx
    call getAbsValue
    pop bx
    
    push dx
    call getAbsValue
    pop dx

    cmp bx, dx
    jl .end
    mov dx, bx
.end:
    mov [bp + 6], dx

    pop dx
    pop bx
    pop bp
    ret 2
endp getMaxAbs

proc multiply
    push bp
    mov bp, sp
    push ax
    push dx
    push cx

    mov ax, [bp + 6]
    mov cx, [bp + 4]

    xor dx, dx
    imul cx
    mov [bp + 6], ax

    pop cx
    pop dx
    pop ax
    pop bp
    ret 2
endp multiply

proc divide
    push bp
    mov bp, sp
    push ax
    push dx
    push cx

    mov ax, [bp + 6]
    mov cx, [bp + 4]

    xor dx, dx
    cwd
    idiv cx
    mov [bp + 6], ax

    pop cx
    pop dx
    pop ax
    pop bp
    ret 2
endp divide

proc getSign
    push bp
    mov bp, sp
    push ax

    cmp [bp + 4], 0
    jnz .isNotZero
    mov ax, 0
    jmp .end
.isNotZero:

    cmp [bp + 4], 0
    jg .isPositive

    mov ax, -1
    jmp .end
.isPositive:
    mov ax, 1

.end:
    mov [bp + 4], ax
    pop ax
    pop bp
    ret
endp getSign

proc getEqual
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 4]
    cmp bx, [bp + 6]
    jne .notEqual
    mov bx, 1
    jmp .end
.notEqual:
    mov bx, 0
.end:
    mov [bp + 6], bx
    pop bx
    pop bp
    ret 2
endp getEqual

proc areControllersCollidingThisFrame
    push bp
    mov bp, sp
    push ax
    push bx
    push si
    push dx
    push di
    mov ax, [bp + 6] ; first controller
    mov dx, [bp + 4] ; collider
    
    push ax
    push dx
    call isXCollision
    pop bx ; x collision

    push ax
    push dx
    call isYCollision
    pop si ; y collision

    cmp bx, 0 ; doesn't collide in x
    jz .setFalse
    cmp si, 0 ; doesn't collide in y
    jz .setFalse

    ; TODO - solve both bx and si equal

    push bx ; x
    push si ; y
    call getMinAbsIndex
    pop ax

    cmp ax, 0
    jz .setX

    mov ax, si
    mov dx, 320
    imul dx
    jmp .end
.setX:
    mov ax, bx
    jmp .end
.setFalse:
    mov ax, 0
.end:
    mov [bp + 6], ax ; change to correctly collide
    pop di
    pop dx
    pop si
    pop bx
    pop ax
    pop bp
    ret 2
endp areControllersCollidingThisFrame

; gets the edge points of 2 objects and return the distance between them,
; and 0 if they don't collide
; input - obj1 bigger, obj2 lower, obj1 bigger, obj lower
; lower - (top/left), bigger - (bottom/right)
proc isAxisCollisionSquare
    push bp
    mov bp, sp
    push cx
    push dx
    push bx
    push ax

    mov ax, [bp + 10]  ; bottom/right1
    mov bx, [bp + 8]   ; top/left1
    mov dx, [bp + 6]   ; bottom/right2
    mov cx, [bp + 4]   ; top/left2

    ; if bottom1 is less than top2
    cmp ax, cx
    jle .setFalse
    ; if bottom2 is less than top1
    cmp dx, bx
    jle .setFalse

    cmp ax, dx ; 1 is above 2
    jge .set2
    sub ax, cx
    jmp .end
.set2:
    sub bx, dx
    mov ax, bx
    jmp .end
.setFalse:
    mov ax, 0
.end:
    mov [bp + 10], ax
    pop ax
    pop bx
    pop dx
    pop cx
    pop bp
    ret 6
endp isAxisCollisionSquare

proc getControllerComponent
    push bp
    mov bp, sp
    push ax
    push bx
    push si

    mov bx, [bp + 6] ; controller
    mov ax, [bp + 4] ; componentId

    mov si, bx
    add si, ControllerComponentData
    dec si

.componentLoop:
    inc si
    mov ah, [si] ; current component id
    cmp al, ah
    jne .componentLoop

    xor ax, ax
    mov al, [si + ComponentLocation]
    add bx, ax

    mov [bp + 6], bx
    pop si
    pop bx
    pop ax
    pop bp
    ret 2
endp getControllerComponent

proc endAndCleanUp
    push offset previousIRQMask
    call cleanUpClock

    mov ah, 0
    mov al, 2
    int 10h
    mov ax, 4C00h
    int 21h
    ret
endp endAndCleanUp

; input - the segment wrapper
; output - the original object
; note - need to execute end, to return to the normal ds
proc StartLoadFromOtherSegment
    push bp
    mov bp, sp
    push bx
    push ax
    push si
    mov bx, [bp + 4]
    mov [bp + 6], ds
    mov ax, [bx + SegmentWrapperSegment]
    mov si, [bx + SegmentWrapperOriginal]
    mov ds, ax
    mov [bp + 4], si
    pop si
    pop ax
    pop bx
    pop bp
    ret
endp StartLoadFromOtherSegment

; called 1024 times a sec
proc periodic
    push bp
    mov bp, sp
    push bx
    push cx
    push dx
    push ax
    mov bx, [bp + 4]
    inc [word ptr bx]
    cmp [word ptr bx], 1025
    jl .skipReset
    mov [word ptr bx], 1
.skipReset:
    mov ax, [bx]
    mov cx, gameSpeed
    xor dx, dx
    div cx
    cmp dx, 0
    jne .skipGameLoop
    call gameLoop
.skipGameLoop:
    pop ax
    pop dx
    pop cx
    pop bx
    pop bp
    ret 2
endp periodic

; setups the keyboard handler
; input - pointer to the old segment save, another for the offset
proc setupKeyboardHandler
    push bp
    mov bp, sp
    push ax
    push es
    xor ax, ax
    mov es, ax ; set es to IVT
    cli
    ; Save the original ISR address
    mov ax, [word ptr es:9*4]
    mov [bp + 4], ax ; save old offset
    mov ax, [word ptr es:9*4+2]
    mov [bp + 6], ax ; save old segment
    ; Set the new ISR address
    mov [word ptr es:9*4], offset keyboardHandler
    mov [word ptr es:9*4+2], seg keyboardHandler
    sti
    pop es
    pop ax
    pop bp
    ret 4
endp setupKeyboardHandler

proc handleBounceCollision
    push bp
    mov bp, sp
    push bx
    push ax

    mov bx, [bp + 6] ; controller

    push bx
    push [bp + 4] ; collider
    call areControllersColliding
    pop ax ; overlap

    cmp ax, 0
    je .end

    ; Move object back by overlap
    push bx
    push ax
    push RenderComponentId
    push RenderComponentPosition
    call addControllerWordValue

    push bx
    push PhysicsComponentId
    call getControllerComponent
    pop bx ; bx = physics component

    push ax
    call getAbsValue
    pop ax
    cmp ax, 320
    jl .bounceX

.bounceY:
    mov ax, [bx + PhysicsComponentVelocityY]
    neg ax
    mov [bx + PhysicsComponentVelocityY], ax
    jmp .end

.bounceX:
    mov ax, [bx + PhysicsComponentVelocityX]
    neg ax
    mov [bx + PhysicsComponentVelocityX], ax

.end:
    pop ax
    pop bx
    pop bp
    ret 4
endp handleBounceCollision

proc handleWallCollision
    push bp
    mov bp, sp
    push bx
    push ax
    mov bx, [bp + 6] ; controller

    push bx
    push [bp + 4] ; collider
    call areControllersColliding
    pop ax ; amount to move

    push bx
    push ax
    push RenderComponentId
    push RenderComponentPosition
    call addControllerWordValue

    cmp ax, 0
    je .end

    push ax
    call getAbsValue
    pop ax
    cmp ax, 320
    jl .skipResetY

    push bx
    push 0
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
    jmp .skipResetX

.skipResetY:

    push bx
    push 0
    push PhysicsComponentId
    push PhysicsComponentVelocityX
    call setControllerWordValue

.skipResetX:

.end:
    pop ax
    pop bx
    pop bp
    ret 4
endp handleWallCollision

proc getArrayElement
    push bp
    mov bp, sp
    push bx
    push dx
    push ax

    mov bx, [bp + 6] ; array
    mov dx, [bp + 4] ; index

    mov ax, [bx + ArrayElementSize]
    mul dx ; ax = index * element size

    add bx, ArrayData
    add bx, ax
    mov bx, [bx]
    mov [bp + 6], bx

    pop ax
    pop dx
    pop bx
    pop bp
    ret 2
endp getArrayElement

proc setArrayElement
    push bp
    mov bp, sp
    push bx
    push si
    push dx
    push ax

    mov bx, [bp + 8] ; array
    mov si, [bp + 6] ; value
    mov ax, [bp + 4] ; index

    mov dx, [bx + ArrayElementSize] ; element size
    mul dx ; ax = index * element size

    add bx, ArrayData ; first element
    add bx, ax

    mov [bx], si

    pop ax
    pop dx
    pop si
    pop bx
    pop bp
    ret 6
endp setArrayElement

proc pushToArray
    push bp
    mov bp, sp
    push bx
    push si
    push dx
    push ax

    mov bx, [bp + 6] ; array
    mov si, [bp + 4] ; value

    mov dx, [bx + ArrayElementSize] ; element size
    mov ax, [bx + ArraySize]        ; array size
    inc [word ptr bx + ArraySize]            ; increase array size
    mul dx                          ; ax = index * element size

    add bx, ArrayData ; first element
    add bx, ax        ; currect element position

    mov [bx], si

    pop ax
    pop dx
    pop si
    pop bx
    pop bp
    ret 4
endp pushToArray

proc popFromArray
    push bp
    mov bp, sp
    push bx
    push dx
    push ax

    mov bx, [bp + 4] ; array

    mov dx, [bx + ArrayElementSize] ; element size
    mov ax, [bx + ArraySize]        ; array size
    dec [word ptr bx + ArraySize]            ; decrease array size
    mul dx                          ; ax = index * element size

    add bx, ArrayData ; first element
    add bx, ax        ; currect element position

    mov bx, [bx]
    mov [bp + 4], bx

    pop ax
    pop dx
    pop bx
    pop bp
    ret
endp popFromArray

proc createArray
    push bp
    mov bp, sp
    push bx
    push si
    push cx

    mov bx, [bp + 8] ; location
    mov si, [bp + 6] ; length
    mov cx, [bp + 4] ; element size
    
    mov [byte ptr bx], ArrayId
    mov [bx + ArrayElementSize], cx
    mov [bx + ArraySize], si

    pop cx
    pop si
    pop bx
    pop bp
    ret 6
endp createArray

proc goThroughArrayDownwards
    push bp
    mov bp, sp
    push bx
    push ax
    push dx

    mov bx, [bp + 6] ; array
    mov dx, [bp + 4] ; current index

    cmp dx, -1
    jnz .continue
    mov dx, [bx + ArraySize]
.continue:
    dec dx
    mov [bp + 4], dx

    push bx
    push dx
    call getArrayElement
    pop bx
    mov [bp + 6], bx

    pop dx
    pop ax
    pop bx
    pop bp
    ret
endp goThroughArrayDownwards

proc goThroughArrayUpwards
    push bp
    mov bp, sp
    push bx
    push ax
    push dx

    mov bx, [bp + 6] ; array
    mov dx, [bp + 4] ; current index

    inc dx
    mov [bp + 4], dx

    mov ax, [bx + ArrayElementSize]
    mul dx ; ax = index * element size

    add bx, ArrayData
    add bx, ax
    mov [bp + 6], bx

    pop dx
    pop ax
    pop bx
    pop bp
    ret
endp goThroughArrayUpwards

proc create2DArray
    push bp
    mov bp, sp
    push bx
    push si
    push cx
    push ax

    mov bx, [bp + 10] ; location
    mov si, [bp + 8]  ; columns
    mov ax, [bp + 6]  ; rows
    mov cx, [bp + 4]  ; element size
    
    mov [byte ptr bx], Array2DId
    mov [bx + Array2DElementSize], cx
    mov [bx + Array2DColumns], si
    mov [bx + Array2DRows], ax

    pop ax
    pop cx
    pop si
    pop bx
    pop bp
    ret 8
endp create2DArray

proc get2DArrayElement
    push bp
    mov bp, sp
    push bx
    push dx
    push ax
    push si

    mov bx, [bp + 8] ; array
    mov si, [bp + 6] ; column
    mov dx, [bp + 4] ; row
    
    mov ax, [bx + Array2DRows]
    mul dx ; ax = rows * row
    add ax, si
    mov dx, [bx + Array2DElementSize]
    mul dx

    add bx, Array2DData
    add bx, ax
    mov bx, [bx]
    mov [bp + 8], bx

    pop si
    pop ax
    pop dx
    pop bx
    pop bp
    ret 4
endp get2DArrayElement

proc get2DArrayRow
    push bp
    mov bp, sp
    push bx
    push dx
    push ax

    mov bx, [bp + 6] ; array
    mov dx, [bp + 4] ; row
    
    mov ax, [bx + Array2DColumns]
    mul dx ; ax = rows * row
    mov dx, [bx + Array2DElementSize]
    mul dx

    add bx, Array2DData
    add bx, ax
    mov [bp + 6], bx

    pop ax
    pop dx
    pop bx
    pop bp
    ret 2
endp get2DArrayRow

proc goThroughRowUpwards
    push bp
    mov bp, sp
    push bx
    push ax
    push dx
    push di

    mov di, [bp + 8] ; 2d array
    mov bx, [bp + 6] ; row array
    mov dx, [bp + 4] ; current index

    cmp dx, -1
    jnz .continue
    mov dx, [di + Array2DColumns]
    sub bx, [di + Array2DElementSize]
.continue:
    dec dx
    mov [bp + 6], dx

    add bx, [di + Array2DElementSize]
    mov [bp + 8], bx

    pop di
    pop dx
    pop ax
    pop bx
    pop bp
    ret 2
endp goThroughRowUpwards

proc goThroughRowDownwards
    push bp
    mov bp, sp
    push bx
    push dx
    push di
    push ax

    mov di, [bp + 8] ; 2d array
    mov bx, [bp + 6] ; row array
    mov dx, [bp + 4] ; current index

    cmp dx, -1
    jnz .continue
    
    mov ax, [di + Array2DElementSize]
    mov dx, [di + Array2DColumns]
    push dx

    inc dx
    mul dx
    add bx, ax

    pop dx

.continue:
    dec dx
    mov [bp + 6], dx

    sub bx, [di + Array2DElementSize]
    mov [bp + 8], bx

    pop ax
    pop di
    pop dx
    pop bx
    pop bp
    ret 2
endp goThroughRowDownwards

proc printChar
    push bp
    mov bp, sp
    push dx
    push ax
    mov dl, [bp + 4]
    add dl, 30h
    mov ah, 2
    int 21h
    mov dl, ' '
    mov ah, 2
    int 21h
    pop ax
    pop dx
    pop bp
    ret 2
endp printChar

proc printNumber
    push bp
    mov bp, sp
    push dx
    push ax
    push cx
    push si

    mov ax, [bp + 4] ; number to print
    mov si, 10
    mov cx, 0

    ; check if negative
    cmp ax, 0
    jge .saveLoop    ; if positive or zero, proceed normally

    ; if negative, print '-' and make number positive for correct ASCII
    push ax
    mov dl, '-'
    mov ah, 2
    int 21h
    pop ax

    neg ax

.saveLoop:
    xor dx, dx
    idiv si  ; ax / 10 -> quotient in ax, remainder in dx

    add dl, '0'  ; Convert remainder to ASCII
    push dx      ; Store digit on stack
    inc cx       ; Count number of digits

    test ax, ax
    jnz .saveLoop

.printLoop:
    pop dx    ; get digit from stack
    mov ah, 2
    int 21h   ; print char

    dec cx
    jnz .printLoop

    ; print space at the end
    mov dl, ' '
    mov ah, 2
    int 21h
    
    pop si
    pop cx
    pop ax
    pop dx
    pop bp
    ret 2
endp printNumber

proc printNumberNew
    push bp
    mov bp, sp
    push dx
    push ax
    push cx
    push si
    push bx

    mov ax, [bp + 4] ; number to print
    mov si, 10
    mov cx, 0
    mov bx, 0

    ; check if negative
    cmp ax, 0
    jge .saveLoop    ; if positive or zero, proceed normally

    push 0
    push 20
    push 20
    push bx 
    call printRectBySize

    ; if negative, print '-' and make number positive for correct ASCII
    push offset letterNeg
    push bx
    call printImage
    add bx, 10

    neg ax

.saveLoop:
    xor dx, dx
    idiv si  ; ax / 10 -> quotient in ax, remainder in dx

    push dx      ; Store digit on stack
    inc cx       ; Count number of digits

    test ax, ax
    jnz .saveLoop

.printLoop:
    pop dx    ; get digit from stack

    push 0
    push 20
    push 20
    push bx 
    call printRectBySize
    
    push offset letterArray
    push dx
    call getArrayElement
    pop si

    push si
    push bx
    call printImage

    add bx, 10
    dec cx
    jnz .printLoop
    
    pop bx
    pop si
    pop cx
    pop ax
    pop dx
    pop bp
    ret 2
endp printNumberNew

proc handleRightPlayer
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 4] ; controller

    cmp [byte ptr KeyStateTable + 23], 0
    je .skipUp

    push bx
    push -100
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
.skipUp:

    cmp [byte ptr KeyStateTable + 37], 0
    je .skipDown

    push bx
    push 100
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
.skipDown:

    pop bx
    pop bp
    ret 2
endp handleRightPlayer

proc handleLeftPlayer
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 4] ; controller

    cmp [byte ptr KeyStateTable + 17], 0
    je .skipUp

    push bx
    push -100
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
.skipUp:

    cmp [byte ptr KeyStateTable + 31], 0
    je .skipDown

    push bx
    push 100
    push PhysicsComponentId
    push PhysicsComponentVelocityY
    call setControllerWordValue
.skipDown:

    pop bx
    pop bp
    ret 2
endp handleLeftPlayer

; prints a controller's hitbox by a color
proc printHitbox
    push bp
    mov bp, sp
    push bx
    mov bx, [bp + 6] ; controller pointer

    push bx
    push RenderComponentId
    call getControllerComponent
    pop bx
    
    push [bp + 4] ; color
    push [bx + RenderComponentWidth]
    push [bx + RenderComponentHeight]
    push [bx + RenderComponentPosition] ; screen position (left top)
    call printRectBySize
    
    pop bx
    pop bp
    ret 4
    ret
endp printHitbox

proc endGameIfCollide
    push bp
    mov bp, sp
    push ax

    push [bp + 6]
    push [bp + 4]
    call areControllersColliding
    pop ax

    cmp ax, 0
    je .end

    call endAndCleanUp
.end:
    pop ax
    pop bp
    ret 4
endp endGameIfCollide

proc printAllColors
    push bp
    mov bp, sp
    push ax
    push cx
    push es
    mov ax, VideoMemory
    mov es, ax
	mov di, 0
.printLoop:
    mov [es:di], di
    inc di
	cmp di, 256
    jne .printLoop
    pop es
    pop cx
    pop ax
    pop bp
	ret
endp printAllColors

proc handleBallAcceleration

    push offset ballController
    push PhysicsComponentId
    push PhysicsComponentVelocityX
    call getControllerWordValue
    pop bx

    cmp bx, 0
    jl .skipPositive

    push offset ballController
    push 1
    push PhysicsComponentId
    push PhysicsComponentVelocityX
    call addControllerWordValue

    jmp .end

.skipPositive:

    push offset ballController
    push -1
    push PhysicsComponentId
    push PhysicsComponentVelocityX
    call addControllerWordValue

.end:

    ret
endp handleBallAcceleration

proc printPoint
    push bp
    mov bp, sp
    push ax
    push es
    push di

    mov ax, VideoMemory
    mov es, ax

    mov di, [bp + 6] ; pos
    mov ax, [bp + 4] ; color

    mov [byte ptr es:di], al

    pop di
    pop es
    pop ax
    pop bp
    ret 4
endp printPoint

proc gameLoop

    push offset leftPlayerController
    call handleLeftPlayer

    push offset rightPlayerController
    call handleRightPlayer

    push offset leftPlayerController
    call updateAndApplyVelocity

    push offset rightPlayerController
    call updateAndApplyVelocity

    cmp [globalTime], 100
    jne .skip
    call handleBallAcceleration
.skip:

    push offset ballController
    push offset borderRight
    call handleBounceCollision

    push offset ballController
    push offset borderLeft
    call handleBounceCollision

    push offset ballController
    push offset borderDown
    call handleBounceCollision

    push offset ballController
    push offset borderUp
    call handleBounceCollision

    ; push offset ballController
    ; push offset borderLeft
    ; call endGameIfCollide

    ; push offset ballController
    ; push offset borderRight
    ; call endGameIfCollide

    push offset ballController
    push offset rightPlayerController
    call handleBounceCollision

    push offset ballController
    push offset leftPlayerController
    call handleBounceCollision

    push offset ballController
    call updateAndApplyVelocity

    push offset printManager
    push offset leftPlayerController
    call uploadController

    push offset printManager
    push offset rightPlayerController
    call uploadController

    push offset printManager
    push offset ballController
    call uploadController

    push offset printManager
    call printAllControllers

    ret
endp gameLoop

start:
    mov ax, @data
    mov ds, ax
    mov ax, 13h
    int 10h

    xor ax, ax
    xor dx, dx
    xor bx, bx
    xor si, si
    xor cx, cx
    xor di, di

    call clearScreen

    push offset palette
    call setPalette

; *******************INIT***************
; Note - here order is important, because they save their background here

    push offset rightPlayerController
    push (320 * 80) + 315
    call initController

    push offset leftPlayerController
    push (320 * 80)
    call initController

    push offset ballController
    push (320 * 100) + 160
    call initController

; **************************************

    push offset oldKeyboardHandlerSegment
    push offset oldKeyboardHandlerOffset
    call setupKeyboardHandler

    push offset previousIRQMask
    call setUpClock

keepAliveLoop:
    jmp keepAliveLoop
exit:
    call endAndCleanUp
END start
